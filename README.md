# stock-analysis
## Overview
The point of this refractoring project was to attempt to create a new system of code that would be more applicable to analyzing a larger set of data. The original code was changed in a way that could allow it to more easily run the same accurate analysis on a set of data containing an unknown but large amount of stock prices. 

### Results

![code_example](https://user-images.githubusercontent.com/111502918/210349254-88be4c60-94de-4075-84d6-29c518acb0e3.PNG)

* As seen in the image above, the code has been altered to increase its ability to efficiently run analysis for increased amounts of data. 

![2017_analysis](https://user-images.githubusercontent.com/111502918/210350237-b53e697d-fe6b-45d2-8ff7-06b029b181b0.PNG)


![2018_analysis](https://user-images.githubusercontent.com/111502918/210350245-ecff076a-8240-495a-9b93-94d49827c351.PNG)


* The images above contain the analysis for the stocks from 2017 and 2018 along with the amount of time it took to run the macro. As seen in the images above, the analysis was ran incredibly efficiently for both years. The 2017 and 2018 analyses were completed in 0.16 seconds.


#### Summary 
* There are pros and cons to refactoring code. As far as pros go, refactoring code saves times, provides a decent foundation, and gives an example of how the code can run when running properly. The existence of the original code can be used as a backbone for the refactored code.
* As far as cons go, having the original example of code can also be used as a crutch that limits creativity and critical thinking. If the original code is used too heavily, the point of refactoring it to begin with is mute.
* As far as this example goes, the pros outweigh the cons. The refactored code is efficient, accurate, and able to be applied to a much larger scale. Fortunately, there weren't many issues to speak of when writing and testing the code, so any potential lack of critical thinking for problem solving didn't arrise. 
